require('dotenv').config();
const puppeteer = require('puppeteer');
const { getYouTubeUrl, isYouTubeShort, isYouTubeLive } = require('../utils/youtube');
const { saveTranscript, getTranscriptFromCache } = require('../utils/cache');
const { exec } = require('child_process');
const util = require('util');
const execAsync = util.promisify(exec);

// Configuration
const CACHE_TRANSCRIPTS = process.env.CACHE_TRANSCRIPTS === 'true';
const MAX_RETRIES = parseInt(process.env.MAX_TRANSCRIPT_RETRIES || '3');
const RETRY_DELAY = parseInt(process.env.TRANSCRIPT_RETRY_DELAY || '5000');

// Configuration
const CACHE_TRANSCRIPTS = process.env.CACHE_TRANSCRIPTS === 'true';
const MAX_RETRIES = parseInt(process.env.MAX_TRANSCRIPT_RETRIES || '3');
const RETRY_DELAY = parseInt(process.env.TRANSCRIPT_RETRY_DELAY || '5000');

/**
 * Launch browser with appropriate configuration
 */
async function launchBrowser() {
  const commonArgs = [
    '--no-sandbox',
    '--disable-setuid-sandbox',
    '--disable-dev-shm-usage',
    '--disable-accelerated-2d-canvas',
    '--disable-gpu',
    '--window-size=1920,1080',
    '--disable-web-security'
  ];

  const opts = {
    headless: 'new',
    args: commonArgs,
    defaultViewport: { width: 1920, height: 1080 }
  };

  if (process.env.NODE_ENV === 'production' && process.env.CHROME_BIN) {
    opts.executablePath = process.env.CHROME_BIN;
  }

  return await puppeteer.launch(opts);
}

/**
 * Extract transcript using yt-dlp
 */
async function getTranscriptWithYtDlp(videoId) {
  try {
    // First, try to get available subtitles
    const { stdout: subsInfo } = await execAsync(`yt-dlp --list-subs https://www.youtube.com/watch?v=${videoId}`);
    console.log('Available subtitles:', subsInfo);

    // Try different methods to get transcript
    const methods = [
      // Method 1: Try auto-generated subtitles
      `yt-dlp --get-auto-subs --sub-lang en --skip-download https://www.youtube.com/watch?v=${videoId}`,
      // Method 2: Try manual subtitles
      `yt-dlp --write-sub --sub-lang en --skip-download https://www.youtube.com/watch?v=${videoId}`,
      // Method 3: Try auto-generated subtitles in any language
      `yt-dlp --get-auto-subs --skip-download https://www.youtube.com/watch?v=${videoId}`,
    ];

    for (const cmd of methods) {
      try {
        const { stdout } = await execAsync(cmd);
        if (stdout && stdout.length > 100) {
          // Clean up the transcript (remove timestamps and formatting)
          const cleaned = stdout
            .replace(/\[.*?\]/g, '') // Remove timestamps
            .replace(/<.*?>/g, '')   // Remove HTML-like tags
            .replace(/\n+/g, ' ')    // Replace newlines with spaces
            .replace(/\s+/g, ' ')    // Normalize spaces
            .trim();

          if (cleaned.length > 100) {
            console.log(`Successfully extracted transcript via yt-dlp (${cleaned.length} chars)`);
            return cleaned;
          }
        }
      } catch (methodError) {
        console.log(`Method failed:`, methodError?.message || methodError);
        continue;
      }
    }
    return null;
  } catch (error) {
    console.error('yt-dlp extraction failed:', error?.message || error);
    return null;
  }
}
    
    for (const options of languageOptions) {
    try {
      const transcriptItems = await YoutubeTranscript.fetchTranscript(videoId, options);
      
      if (!Array.isArray(transcriptItems) || transcriptItems.length === 0) {
        continue;
      }

      const sentences = [];
      let currentSentence = '';
      
      for (const item of transcriptItems) {
        const text = item.text.trim();
        if (!text) continue;
        
        if (text.endsWith('.') || text.endsWith('!') || text.endsWith('?')) {
          currentSentence += (currentSentence ? ' ' : '') + text;
          sentences.push(currentSentence);
          currentSentence = '';
        } else {
          currentSentence += (currentSentence ? ' ' : '') + text;
        }
      }
      
      if (currentSentence) {
        sentences.push(currentSentence);
      }
      
      const transcript = sentences.join('. ').replace(/\.\./g, '.');
      if (transcript.length > 100) {
        console.log(`Successfully extracted transcript via API (${transcript.length} chars)`);
        return transcript;
      }
    } catch (error) {
      const msg = error?.message || error;
      console.log(`API attempt failed:`, msg);
      
      // Extract available language info from error message
      if (typeof msg === 'string' && msg.includes('Available languages:')) {
        languageError = msg;
        const langs = msg.split('Available languages:')[1].trim().split(',').map(l => l.trim());
        for (const lang of langs) {
          if (!languageOptions.some(opt => opt?.lang === lang)) {
            languageOptions.push({ lang });
          }
        }
        continue; // Try with the new language option
      }
    }
  }
  
  if (languageError) {
    console.log('Attempted all available languages without success');
  }
  return null;
}

/**
 * Extract transcript by scraping YouTube page
 */
async function getTranscriptDirectFromYouTube(videoId) {
  let browser = null;
  let retryCount = 0;
  
  while (retryCount < MAX_RETRIES) {
    try {
      if (retryCount > 0) {
        await new Promise(r => setTimeout(r, RETRY_DELAY * Math.pow(2, retryCount - 1))); // Exponential backoff
      }
      
      browser = await launchBrowser();
      const page = await browser.newPage();
      
      const url = getYouTubeUrl(videoId);
      await page.goto(url, { waitUntil: 'domcontentloaded', timeout: 30000 });
      
      const selectors = [
        'ytd-transcript-body-renderer',
        'ytd-transcript-segment-list-renderer',
        '#segments-container'
      ];

      for (const selector of selectors) {
        try {
          await page.waitForSelector(selector, { timeout: 5000 });
          const text = await page.$eval(selector, el => el.innerText);
          if (text && text.length > 100) {
            console.log(`Successfully extracted transcript via scraping (${text.length} chars)`);
            return text;
          }
        } catch (error) {
          continue;
        }
      }
      
      retryCount++;
    } catch (error) {
      console.error(`Scraping attempt ${retryCount + 1} failed:`, error?.message || error);
      retryCount++;
    } finally {
      if (browser) {
        await browser.close();
      }
    }
  }
  
  return null;
}

/**
 * Main transcript extraction function
 */
async function getTranscript(videoId) {
  try {
    const url = getYouTubeUrl(videoId);
    
    // Check video type
    if (isYouTubeShort(url)) {
      console.log(`Skipping YouTube Short: ${videoId}`);
      return null;
    }
    
    if (await isYouTubeLive(url)) {
      console.log(`Skipping Live video: ${videoId}`);
      return null;
    }

    // Check cache first
    if (CACHE_TRANSCRIPTS) {
      const cached = await getTranscriptFromCache(videoId);
      if (cached) {
        console.log(`Using cached transcript for ${videoId}`);
        return cached;
      }
    }

    // Try yt-dlp first
    console.log('Attempting yt-dlp extraction...');
    const ytDlpTranscript = await getTranscriptWithYtDlp(videoId);
    if (ytDlpTranscript) {
      if (CACHE_TRANSCRIPTS) {
        await saveTranscript(videoId, ytDlpTranscript);
      }
      return ytDlpTranscript;
    }

    // Fallback to direct scraping if yt-dlp fails
    console.log('yt-dlp failed, attempting direct extraction...');
    const scrapedTranscript = await getTranscriptDirectFromYouTube(videoId);
    if (scrapedTranscript) {
      if (CACHE_TRANSCRIPTS) {
        await saveTranscript(videoId, scrapedTranscript);
      }
      return scrapedTranscript;
    }

    console.log('All extraction methods failed');
    return null;
  } catch (error) {
    console.error('Fatal error in transcript extraction:', error);
    return null;
  }
}

module.exports = {
  getTranscript
};
